# üß© **5. Reducci√≥n de Dimensionalidad** {-}   

**Ejemplos:** PCA, t-SNE, UMAP   
**Cu√°ndo usarlo:**   

* Visualizaci√≥n de datos de alta dimensi√≥n.
* Preprocesamiento para eliminar ruido o multicolinealidad.

**Ventajas:** Mejora desempe√±o y velocidad de otros modelos.    
**Limitaciones:** Puede perder interpretabilidad; no siempre mejora modelos.

---

## Principal Component Analysis (PCA)  {-}   

**Principal Component Analysis (PCA)** es una t√©cnica fundamental de **reducci√≥n de dimensionalidad** no supervisada que se utiliza para transformar un conjunto de variables posiblemente correlacionadas en un conjunto de variables no correlacionadas llamadas **componentes principales**. La idea fundamental de PCA es identificar las direcciones (ejes) en el espacio de los datos a lo largo de las cuales la **varianza de los datos es m√°xima**. Estas nuevas direcciones son ortogonales entre s√≠ y representan la mayor parte de la informaci√≥n (varianza) contenida en el conjunto de datos original con un n√∫mero reducido de dimensiones.

El proceso de PCA generalmente implica los siguientes pasos:

1.  **Estandarizaci√≥n de los Datos:** Es crucial estandarizar los datos (centrar en cero y escalar a varianza unitaria) antes de aplicar PCA, ya que PCA es sensible a la escala de las variables.
2.  **C√°lculo de la Matriz de Covarianza:** Se calcula la matriz de covarianza de los datos estandarizados, que describe la relaci√≥n entre cada par de variables.
3.  **C√°lculo de Eigenvalores y Eigenvectores:** Se calculan los **eigenvalores** y **eigenvectores** de la matriz de covarianza.
    * Los **eigenvectores** representan las **direcciones de los componentes principales** (los nuevos ejes en el espacio de los datos). El primer eigenvector corresponde a la direcci√≥n de mayor varianza, el segundo a la segunda mayor varianza, y as√≠ sucesivamente.
    * Los **eigenvalores** corresponden a la **magnitud de la varianza** a lo largo de cada eigenvector. Un eigenvalor m√°s grande indica que el componente principal asociado explica una mayor proporci√≥n de la varianza total de los datos.
4.  **Selecci√≥n de Componentes Principales:** Se ordenan los eigenvalores de mayor a menor y se seleccionan los $k$ eigenvectores correspondientes a los $k$ eigenvalores m√°s grandes. Estos $k$ eigenvectores forman la nueva base del subespacio dimensional reducido. La elecci√≥n de $k$ se puede basar en la varianza acumulada deseada o en un gr√°fico de codo (scree plot).
5.  **Proyecci√≥n de Datos:** Finalmente, se proyectan los datos originales sobre estos $k$ componentes principales para obtener un nuevo conjunto de datos con menor dimensionalidad pero que retiene la mayor parte de la varianza original.

En el contexto del **aprendizaje global vs. local**, PCA es inherentemente un m√©todo de **aprendizaje global**. Busca una transformaci√≥n lineal que capture la estructura de varianza **global** de todo el conjunto de datos. No divide el problema en subproblemas locales ni se enfoca en regiones espec√≠ficas de los datos. La idea es que, si los datos no se distribuyen linealmente, PCA (en su forma lineal) **no puede capturar relaciones no lineales complejas** de manera efectiva. Est√° limitado a encontrar las direcciones ortogonales de m√°xima varianza en un espacio lineal.

A diferencia de LOESS, que aplica una forma de regresi√≥n ponderada localmente para ajustar curvas suaves en datos no lineales, PCA no est√° dise√±ado para eso. Precisamente porque busca una representaci√≥n lineal global, si la estructura subyacente de los datos es intr√≠nsecamente no lineal, PCA puede no ser capaz de proporcionar una reducci√≥n de dimensionalidad suficientemente buena o capturar las relaciones esenciales. En tales casos, se recurre a t√©cnicas de reducci√≥n de dimensionalidad no lineal como t-SNE o UMAP, o a variantes de PCA como Kernel PCA. No obstante, PCA sigue siendo una herramienta fundamental y muy √∫til para la visualizaci√≥n de datos, la reducci√≥n de ruido y la preparaci√≥n de datos para otros algoritmos, especialmente cuando la varianza se explica bien por relaciones lineales o cuando la dimensionalidad es un problema para la eficiencia computacional.


```{r, echo = FALSE}
criterios <- c(
  "Tipo de modelo",
  "Variable respuesta",
  "Variables predictoras",
  "Relaci√≥n entre variables",
  "Normalidad de residuos",
  "Independencia de errores",
  "Homoscedasticidad",
  "Sensible a outliers",
  "Multicolinealidad entre predictores",
  "Interpretabilidad",
  "Velocidad y eficiencia",
  "Validaci√≥n cruzada",
  "No funciona bien si..."
)

aplica <- c(
  "‚ö†Ô∏è No supervisado (reducci√≥n de dimensiones)",
  "‚ùå No aplica (no hay target a predecir)",
  "‚úÖ Num√©ricas (requiere escalado), categ√≥ricas procesadas como dummies",
  "‚úÖ Captura correlaciones lineales entre predictores",
  "‚ùå No requiere supuestos de distribuci√≥n en residuos",
  "‚ö†Ô∏è Ideal si las observaciones son independientes, aunque no cr√≠tico",
  "‚úÖ Deseable (datos homogenizados tras escalado)",
  "‚ö†Ô∏è Moderado (outliers pueden distorsionar componentes principales)",
  "‚úÖ Sensible a colinealidad (reduce variables correlacionadas a componentes)",
  "‚ö†Ô∏è Media (componentes lineales son interpretables, pero combinaciones pueden no serlo)",
  "‚úÖ R√°pido en datasets medianos; escalable con √°lgebra lineal optimizada",
  "‚ö†Ô∏è No se aplica CV cl√°sico; se puede usar reconstrucci√≥n de error o validaci√≥n por bloques",
  "‚ùå No funciona bien si las relaciones son no lineales o datos muy ruidosos sin preprocesar"
)

detalles <- c(
  "M√©todo no supervisado para reducir la dimensi√≥n del espacio de predictores.",
  "No predice variables, se centra en variabilidad interna de los datos.",
  "Todas las variables num√©ricas deben escalarse; las categ√≥ricas convertir a variables indicadoras.",
  "Busca direcciones (componentes) que maximizan varianza lineal entre predictores.",
  "No impone supuestos sobre errores; se basa en descomposici√≥n de la matriz de covarianza.",
  "Mejor si las muestras no est√°n correlacionadas en el tiempo o espacialmente.",
  "Escalar y homogeneizar mejora el c√°lculo de componentes principales.",
  "Outliers extremos pueden sesgar la direcci√≥n de los componentes principales.",
  "Reduce colinealidad al combinar variables correlacionadas en componentes ortogonales.",
  "Componentes iniciales pueden interpretarse mediante pesos, pero componentes posteriores son combinaciones lineales complejas.",
  "Computaci√≥n depende de descomposici√≥n de matrices (SVD), es eficiente con optimizaci√≥n BLAS.",
  "Se puede evaluar n√∫mero √≥ptimo de componentes con validaci√≥n de reconstrucci√≥n o bootstrap de SVD.",
  "No apto para relaciones no lineales complejas; en tal caso usar Kernel PCA o m√©todos no lineales."
)

tabla_pca <- data.frame(Criterio = criterios, Aplica = aplica, Detalles = detalles)

tabla_pca %>%
 gt() %>%
  tab_header(title = "Gu√≠a r√°pida para elegir PCA",
             subtitle = "Principal Component Analysis (PCA)")  %>%
   tab_footnote(footnote = "Fuente: Elaboraci√≥n propia") %>%
     tab_options(heading.title.font.size = 14, 
                 heading.subtitle.font.size = 12,
                 table.font.names = "Century Gothic",
                 table.font.size = 10,
                 data_row.padding = px(1)) %>%
      tab_style(style = list(cell_text(align = "left",
                                       weight = 'bold')),
                locations = list(cells_title(groups = c("title")))) %>%
       tab_style(style = list(cell_text(align = "left")),
                 locations = list(cells_title(groups = c("subtitle")))) %>%
        cols_width(starts_with("Detalles") ~ px(500),
                   everything() ~ px(200)) %>%
         as_raw_html() 
```

## Partial Least Squares Regression (PLSR)  {-}    

**Partial Least Squares Regression (PLSR)** es una t√©cnica de **regresi√≥n multivariada** que combina caracter√≠sticas de la **regresi√≥n por m√≠nimos cuadrados ordinarios (OLS)** y el **an√°lisis de componentes principales (PCA)**. Se utiliza para modelar la relaci√≥n entre un conjunto de variables predictoras (X) y uno o m√°s conjuntos de variables de respuesta (Y), siendo particularmente √∫til en situaciones donde hay un gran n√∫mero de variables predictoras, **multicolinealidad** (altas correlaciones entre las variables predictoras), o cuando el n√∫mero de predictoras excede el n√∫mero de observaciones.

La idea fundamental de PLSR es encontrar un conjunto de **componentes latentes** (tambi√©n conocidos como "factores" o "variables latentes") tanto en el espacio de las variables X como en el de las variables Y. Estos componentes se construyen de tal manera que **maximizan la covarianza** entre las variables predictoras y las variables de respuesta. A diferencia de PCA, que solo busca componentes que expliquen la m√°xima varianza en X, PLSR busca componentes que sean relevantes para explicar la varianza en X *y* que tambi√©n est√©n altamente correlacionados con Y. Una vez que se extraen estos componentes, se realiza una regresi√≥n de m√≠nimos cuadrados ordinarios de Y sobre estos componentes latentes.

El proceso general de PLSR implica:

1.  **Extracci√≥n de Componentes Latentes:** PLSR construye iterativamente un conjunto de componentes latentes. En cada paso:
    * Identifica una combinaci√≥n lineal de las variables X (un componente de X) y una combinaci√≥n lineal de las variables Y (un componente de Y) que tienen la mayor covarianza entre s√≠.
    * Estos componentes representan las direcciones en el espacio de datos que explican la mayor cantidad de la relaci√≥n entre X y Y.
    * Una vez que se extrae un componente, la varianza explicada por ese componente se "deflacta" (se elimina) de las matrices X e Y, y el proceso se repite con los residuos para encontrar el siguiente componente ortogonal.
2.  **Regresi√≥n:** Una vez que se ha determinado el n√∫mero √≥ptimo de componentes latentes (a menudo a trav√©s de validaci√≥n cruzada), se realiza una regresi√≥n lineal est√°ndar de las variables Y sobre estos componentes latentes de X.

**Ventajas clave de PLSR:**

* **Manejo de Multicolinealidad:** Es muy efectivo en la reducci√≥n de dimensionalidad y el manejo de predictoras altamente correlacionadas, donde la regresi√≥n OLS fallar√≠a o producir√≠a estimaciones inestables.
* **Manejo de Datos de Alta Dimensionalidad:** Funciona bien cuando el n√∫mero de variables predictoras es mayor que el n√∫mero de observaciones.
* **Enfoque Predictivo:** Se centra en desarrollar modelos con una fuerte capacidad predictiva.

En el contexto del **aprendizaje global vs. local**, PLSR es un algoritmo de **aprendizaje global**. Busca una transformaci√≥n lineal global de los datos originales en un espacio de componentes latentes, donde se maximiza la covarianza entre los conjuntos de variables predictoras y de respuesta. La relaci√≥n que modela es una relaci√≥n lineal global en este espacio transformado.

Si bien PLSR no es un m√©todo de **regresi√≥n ponderada localmente** como LOESS (que ajusta modelos simples a subconjuntos locales de datos), comparte con ellos el objetivo de modelar relaciones complejas. Sin embargo, lo hace de una manera diferente. En lugar de dividir el espacio de caracter√≠sticas y aplicar modelos locales, PLSR transforma el espacio de caracter√≠sticas de forma global para encontrar una representaci√≥n de menor dimensionalidad que sea √≥ptima para la predicci√≥n. Cuando los datos no se distribuyen linealmente, PLSR puede no ser la herramienta m√°s adecuada en su forma lineal b√°sica, ya que sigue siendo una t√©cnica lineal. Sin embargo, al encontrar las direcciones m√°s relevantes en el espacio de los datos, puede capturar aspectos importantes de la estructura de los datos que son √∫tiles incluso si la relaci√≥n subyacente es no lineal. Para manejar la no linealidad expl√≠citamente, existen extensiones como **Nonlinear Partial Least Squares (NPLS)** o **Kernel PLS (KPLS)**, que introducen funciones kernel para mapear los datos a un espacio de caracter√≠sticas de mayor dimensi√≥n donde la relaci√≥n podr√≠a ser linealmente modelable por PLS.


```{r, echo = FALSE}
criterios <- c(
  "Tipo de modelo",
  "Variable respuesta",
  "Variables predictoras",
  "Relaci√≥n entre variables",
  "Normalidad de residuos",
  "Independencia de errores",
  "Homoscedasticidad",
  "Sensible a outliers",
  "Multicolinealidad entre predictores",
  "Interpretabilidad",
  "Velocidad y eficiencia",
  "Validaci√≥n cruzada",
  "No funciona bien si..."
)

aplica <- c(
  "‚ö†Ô∏è Supervisado (regresi√≥n y clasificaci√≥n con adaptaci√≥n)",
  "‚úÖ Continua (regresi√≥n) o Categ√≥rica (clasificaci√≥n si se transforma)",
  "‚úÖ Num√©ricas (requiere escalado), categ√≥ricas como dummies",
  "‚úÖ Captura relaciones lineales y reduce dimensiones simult√°neamente",
  "‚ùå No requiere estrictamente, pero mejora con residuos normales",
  "‚úÖ Deseable, aunque no cr√≠tico",
  "‚úÖ Deseable para homogeneizar varianza tras escalado",
  "‚ö†Ô∏è Moderado (outliers pueden influir en componentes latentes)",
  "‚úÖ Dise√±ado para alta colinealidad entre predictores",
  "‚ö†Ô∏è Media (componentes latentes son interpretables, pero relaciones pueden ser complejas)",
  "‚ö†Ô∏è Moderada (depende de n√∫mero de componentes y tama√±o del dataset)",
  "‚úÖ Usar k-fold para elegir n√∫mero de componentes √≥ptimos",
  "‚ùå No funciona bien si relaciones son muy no lineales o datos muy ruidosos sin preprocesar"
)

detalles <- c(
  "Modelo que proyecta predictores y respuesta a espacios latentes para maximizar covarianza.",
  "PLSR encuentra componentes que explican varianza en X y covarianza con Y.",
  "Todas las variables num√©ricas deben escalarse; convertir categ√≥ricas en indicadores.",
  "Combina reducci√≥n de dimensi√≥n (PCA-like) con regresi√≥n en componentes latentes.",
  "No impone supuestos estrictos, pero residuos normales facilitan inferencia estad√≠stica.",
  "Mejor si muestras son independientes; RLSR en datos correlacionados requiere cuidado.",
  "Escalar y homogeneizar predictores e incluso respuesta mejora la estabilidad.",
  "Outliers extremos pueden distorsionar c√°lculo de componentes; usar robust PLSR para mitigarlo.",
  "PLSR maneja colinealidad al construir pocas componentes que representan grupos de variables correlacionadas.",
  "Componentes latentes tienen pesos interpretables, pero interpretar combinaciones puede ser complejo.",
  "El m√©todo usa descomposici√≥n de matrices; eficiente con BLAS/LAPACK optimizado.",
  "Validaci√≥n cruzada ayuda a determinar el n√∫mero √≥ptimo de componentes latentes a usar.",
  "No es adecuado para relaciones puramente no lineales; en ese caso usar Kernel PLSR o m√©todos no lineales."
)

tabla_plsr <- data.frame(Criterio = criterios, Aplica = aplica, Detalles = detalles)

tabla_plsr %>%
 gt() %>%
  tab_header(title = "Gu√≠a r√°pida para elegir PLSR",
             subtitle = "Partial Least Squares Regression (PLSR)")  %>%
   tab_footnote(footnote = "Fuente: Elaboraci√≥n propia") %>%
     tab_options(heading.title.font.size = 14, 
                 heading.subtitle.font.size = 12,
                 table.font.names = "Century Gothic",
                 table.font.size = 10,
                 data_row.padding = px(1)) %>%
      tab_style(style = list(cell_text(align = "left",
                                       weight = 'bold')),
                locations = list(cells_title(groups = c("title")))) %>%
       tab_style(style = list(cell_text(align = "left")),
                 locations = list(cells_title(groups = c("subtitle")))) %>%
        cols_width(starts_with("Detalles") ~ px(500),
                   everything() ~ px(200)) %>%
         as_raw_html() 
```

## Sammon Mapping  {-}   

**Sammon Mapping**, tambi√©n conocida como **Sammon's Nonlinear Mapping (NLM)**, es una t√©cnica de **reducci√≥n de dimensionalidad no lineal** utilizada principalmente para **visualizaci√≥n de datos**. La idea fundamental de Sammon Mapping es proyectar un conjunto de datos de un espacio de alta dimensi√≥n a un espacio de menor dimensi√≥n (t√≠picamente 2D o 3D) de tal manera que se preserve lo mejor posible la **estructura de las distancias entre los puntos** del espacio original. Es decir, si dos puntos estaban cerca en el espacio de alta dimensi√≥n, se espera que tambi√©n est√©n cerca en el espacio de baja dimensi√≥n, y viceversa.

A diferencia de t√©cnicas lineales como PCA, que se enfocan en preservar la varianza o la covarianza, Sammon Mapping se centra en preservar las **distancias por pares** entre los puntos. Para lograr esto, utiliza un algoritmo iterativo que busca minimizar una **funci√≥n de error de Sammon**. Esta funci√≥n mide la diferencia entre las distancias por pares en el espacio de alta dimensi√≥n y las distancias correspondientes en el espacio de baja dimensi√≥n, ponderando m√°s los errores para los puntos que est√°n m√°s cerca en el espacio original. Esto significa que Sammon Mapping presta especial atenci√≥n a preservar la estructura local del conjunto de datos.

La funci√≥n de error de Sammon ($E$) se define como:
$$E = \frac{1}{\sum_{i < j} d_{ij}^* } \sum_{i < j} \frac{(d_{ij}^* - d_{ij})^2}{d_{ij}^*}$$
Donde:
* $d_{ij}^*$ es la distancia euclidiana entre el punto $i$ y el punto $j$ en el espacio de alta dimensi√≥n.
* $d_{ij}$ es la distancia euclidiana entre el punto $i$ y el punto $j$ en el espacio de baja dimensi√≥n.

El algoritmo busca iterativamente las coordenadas de los puntos en el espacio de baja dimensi√≥n que minimizan esta funci√≥n de error, utilizando un m√©todo de **descenso de gradiente**.

En el contexto del **aprendizaje global vs. local**, Sammon Mapping es una t√©cnica que busca un compromiso entre la preservaci√≥n de la estructura **local** y **global** de los datos. Sin embargo, su √©nfasis en ponderar los errores de las distancias peque√±as (puntos cercanos) hace que sea m√°s sensible a la **estructura local** del conjunto de datos. La idea es que, si los datos no se distribuyen linealmente, Sammon Mapping puede generar una representaci√≥n en baja dimensi√≥n que revele agrupaciones y patrones que no ser√≠an evidentes con t√©cnicas lineales como PCA. A diferencia de un m√©todo de regresi√≥n ponderada localmente como LOESS, que se enfoca en ajustar una curva, Sammon Mapping se dedica a la visualizaci√≥n de la estructura de similitud. Al intentar preservar las relaciones de distancia no lineales, aborda directamente la desventaja de que "a veces ning√∫n valor de par√°metro puede proporcionar una aproximaci√≥n suficientemente buena" en las proyecciones lineales, ya que se adapta a la curvatura y la estructura intr√≠nseca no lineal de los datos para ofrecer una visualizaci√≥n m√°s fiel. Aunque puede ser computacionalmente intensivo para conjuntos de datos muy grandes, es una herramienta valiosa para explorar la estructura oculta en datos complejos.


```{r, echo = FALSE}
criterios <- c(
  "Tipo de modelo",
  "Variable respuesta",
  "Variables predictoras",
  "Relaci√≥n entre variables",
  "Normalidad de residuos",
  "Independencia de errores",
  "Homoscedasticidad",
  "Sensible a outliers",
  "Multicolinealidad entre predictores",
  "Interpretabilidad",
  "Velocidad y eficiencia",
  "Validaci√≥n cruzada",
  "No funciona bien si..."
)

aplica <- c(
  "‚ùå No supervisado (reducci√≥n de dimensionalidad)",
  "‚ùå No aplica (no hay variable respuesta)",
  "‚úÖ Num√©ricas (distancias euclidianas)",
  "‚úÖ No lineal, mantiene distancias entre puntos",
  "‚ùå No aplica",
  "‚ùå No aplica",
  "‚ùå No aplica",
  "‚ö†Ô∏è S√≠, es sensible a valores at√≠picos",
  "‚ö†Ô∏è No afecta directamente (no hay predictores)",
  "‚ö†Ô∏è Interpretaci√≥n visual en 2D o 3D; no en componentes",
  "‚ùå Lento para conjuntos grandes (algoritmo iterativo)",
  "‚ö†Ô∏è Se puede validar visualmente o con estr√©s",
  "‚ùå Mal desempe√±o en datos ruidosos o de alta dimensi√≥n sin estructura"

)

detalles <- c(
  "M√©todo no supervisado para proyectar datos de alta dimensi√≥n en espacios de menor dimensi√≥n preservando distancias.",
  "No busca predecir, sino representar relaciones de cercan√≠a entre observaciones.",
  "Usa distancias entre puntos; solo variables num√©ricas tienen sentido.",
  "A diferencia de PCA, Sammon busca preservar distancias relativas entre puntos originales y proyectados.",
  "No genera residuos como un modelo predictivo, por lo tanto no se aplica la normalidad.",
  "No hay modelo de error porque no hay predicci√≥n.",
  "No aplica el supuesto de homoscedasticidad.",
  "Valores extremos alteran las distancias y distorsionan el mapa resultante.",
  "Como es una t√©cnica de reducci√≥n, no le afecta multicolinealidad directamente.",
  "El mapa resultante puede interpretarse en t√©rminos de proximidad, no de pesos o coeficientes.",
  "Implementaci√≥n cl√°sica es iterativa y costosa computacionalmente en datasets grandes.",
  "Puede usarse estr√©s (error entre distancias originales y proyectadas) como m√©trica de calidad.",
  "Si las distancias no reflejan bien la estructura real (por ruido o dimensiones irrelevantes), el m√©todo falla en representar datos √∫tiles."
)

tabla_sammon <- data.frame(Criterio = criterios, Aplica = aplica, Detalles = detalles)

tabla_sammon %>%
 gt() %>%
  tab_header(title = "Gu√≠a r√°pida para elegir sammon mapping",
             subtitle = "Sammon Mapping")  %>%
   tab_footnote(footnote = "Fuente: Elaboraci√≥n propia") %>%
     tab_options(heading.title.font.size = 14, 
                 heading.subtitle.font.size = 12,
                 table.font.names = "Century Gothic",
                 table.font.size = 10,
                 data_row.padding = px(1)) %>%
      tab_style(style = list(cell_text(align = "left",
                                       weight = 'bold')),
                locations = list(cells_title(groups = c("title")))) %>%
       tab_style(style = list(cell_text(align = "left")),
                 locations = list(cells_title(groups = c("subtitle")))) %>%
        cols_width(starts_with("Detalles") ~ px(500),
                   everything() ~ px(200)) %>%
         as_raw_html() 
```

## Multidimensional Scaling (MDS)  {-}    


**Multidimensional Scaling (MDS)** es una t√©cnica de **reducci√≥n de dimensionalidad** utilizada principalmente para la **visualizaci√≥n de datos** y el an√°lisis exploratorio. La idea fundamental de MDS es representar un conjunto de objetos (puntos de datos) en un espacio de baja dimensi√≥n (t√≠picamente 2D o 3D) de tal manera que las **distancias o disimilitudes entre los objetos en el espacio de baja dimensi√≥n reflejen lo m√°s fielmente posible sus distancias o disimilitudes originales** en el espacio de alta dimensi√≥n o en funci√≥n de una matriz de disimilitudes dada.

A diferencia de PCA, que opera directamente sobre una matriz de datos original (variables x observaciones), MDS t√≠picamente toma como entrada una **matriz de disimilitud** (o similitud) entre cada par de objetos. Esta matriz de disimilitud puede ser calculada a partir de las caracter√≠sticas de los objetos (ej., distancia euclidiana, distancia de Manhattan) o puede ser una medida subjetiva de disimilitud (ej., juicios humanos sobre la similitud entre productos).

Existen varias variantes de MDS, pero las m√°s comunes son:

1.  **MDS Cl√°sico (PCoA - Principal Coordinates Analysis):** Es la forma m√°s b√°sica de MDS. Asume que las disimilitudes son distancias euclidianas y es matem√°ticamente equivalente a PCA cuando se trabaja con una matriz de covarianza derivada de datos centrados. Sin embargo, su input es una matriz de disimilitudes, no directamente los datos originales.
2.  **MDS M√©trica:** Minimiza una funci√≥n de costo que mide la diferencia entre las disimilitudes observadas y las distancias en el espacio de baja dimensi√≥n. Utiliza una m√©trica de distancia espec√≠fica (ej., euclidiana).
3.  **MDS No M√©trica:** Es m√°s flexible y se utiliza cuando las disimilitudes originales son solo de naturaleza ordinal (es decir, solo sabemos que un par es "m√°s dis√≠mil" que otro, pero no la magnitud exacta de la diferencia). En lugar de preservar las distancias exactas, intenta preservar el **orden de las disimilitudes**. Minimiza una funci√≥n de costo que mide la monoton√≠a de la relaci√≥n entre las disimilitudes originales y las distancias en el espacio de baja dimensi√≥n.

El algoritmo MDS busca iterativamente las coordenadas de los puntos en el espacio de baja dimensi√≥n que minimizan una **funci√≥n de estr√©s (stress function)** o **funci√≥n de ajuste (badness-of-fit function)**. Esta funci√≥n cuantifica qu√© tan bien las distancias en la representaci√≥n de baja dimensi√≥n se ajustan a las disimilitudes originales.

En el contexto del **aprendizaje global vs. local**, MDS es un sistema que busca una representaci√≥n **global** de la estructura de las distancias. A diferencia de LOESS, que ajusta modelos a subconjuntos locales de datos, MDS intenta preservar la totalidad de las relaciones de disimilitud en una proyecci√≥n de menor dimensi√≥n. Sin embargo, su capacidad para manejar la no linealidad depende de la variante:

* **MDS Cl√°sico/M√©trico** son esencialmente m√©todos **lineales** en cuanto a la forma en que proyectan las distancias. Si los datos no se distribuyen linealmente y sus disimilitudes no son bien representadas por distancias euclidianas en un espacio de baja dimensi√≥n lineal, estos m√©todos pueden no proporcionar una buena visualizaci√≥n de la estructura intr√≠nseca. En este sentido, "a veces ning√∫n valor de par√°metro puede proporcionar una aproximaci√≥n suficientemente buena" si la relaci√≥n subyacente es fuertemente no lineal.
* **MDS No M√©trica**, al preservar el orden de las disimilitudes en lugar de las magnitudes exactas, tiene una capacidad mucho mayor para descubrir y visualizar **estructuras no lineales** en los datos. Se adapta a la forma en que las disimilitudes se "escalan" y, por lo tanto, puede ser visto como un m√©todo que busca una representaci√≥n de funci√≥n global que acomoda la no linealidad inherente en las relaciones de disimilitud.

En resumen, MDS es una herramienta poderosa para revelar la estructura latente en conjuntos de datos bas√°ndose en sus disimilitudes, y su variante no m√©trica es particularmente valiosa cuando se sospecha que las relaciones subyacentes son no lineales. 


```{r, echo = FALSE}
criterios <- c(
  "Tipo de modelo",
  "Variable respuesta",
  "Variables predictoras",
  "Relaci√≥n entre variables",
  "Normalidad de residuos",
  "Independencia de errores",
  "Homoscedasticidad",
  "Sensible a outliers",
  "Multicolinealidad entre predictores",
  "Interpretabilidad",
  "Velocidad y eficiencia",
  "Validaci√≥n cruzada",
  "No funciona bien si..."
)

aplica <- c(
  "‚ùå No supervisado (reducci√≥n de dimensionalidad)",
  "‚ùå No aplica (no hay variable respuesta)",
  "‚úÖ Num√©ricas (requiere matriz de distancias)",
  "‚úÖ No lineal en MDS no cl√°sico; lineal en MDS cl√°sico",
  "‚ùå No aplica",
  "‚ùå No aplica",
  "‚ùå No aplica",
  "‚ö†Ô∏è S√≠, valores at√≠picos afectan distancias",
  "‚ö†Ô∏è No afecta directamente (no hay predictores)",
  "‚ö†Ô∏è Interpretaci√≥n visual en 2D o 3D, no en ejes significativos",
  "‚ùå Lento si se usan distancias complejas o muchos puntos",
  "‚ö†Ô∏è Validaci√≥n mediante 'stress' y visualizaci√≥n",
  "‚ùå Mal desempe√±o con datos sin estructura o ruido elevado"
)

detalles <- c(
  "M√©todo no supervisado que proyecta datos de alta dimensi√≥n en espacios de 2D o 3D preservando distancias entre puntos.",
  "No busca predecir una variable, solo representar relaciones de cercan√≠a entre observaciones.",
  "Se basa en distancias euclidianas u otras m√©tricas aplicadas a datos num√©ricos.",
  "MDS cl√°sico es lineal; el no cl√°sico (por ejemplo metric o non-metric MDS) puede modelar relaciones no lineales.",
  "No se modelan residuos, por lo que no aplica la normalidad.",
  "No hay errores de predicci√≥n, por tanto no aplica este supuesto.",
  "No hay varianzas residuales, por lo que este supuesto tampoco aplica.",
  "Valores extremos modifican distancias y distorsionan la representaci√≥n espacial.",
  "Al no haber regresores, la multicolinealidad no es un problema.",
  "El mapa generado se interpreta por proximidad relativa, no por pesos o coeficientes.",
  "Puede ser costoso computacionalmente si hay muchos puntos o si se optimiza la funci√≥n de estr√©s.",
  "Se eval√∫a qu√© tan bien se preservan las distancias originales con la m√©trica de estr√©s o visualmente.",
  "No funciona bien si los datos no tienen estructura clara, est√°n muy dispersos o contienen ruido irrelevante."
)

tabla_mds <- data.frame(Criterio = criterios, Aplica = aplica, Detalles = detalles)

tabla_mds %>%
 gt() %>%
  tab_header(title = "Gu√≠a r√°pida para elegir MDS",
             subtitle = "Multidimensional Scaling (MDS)")  %>%
   tab_footnote(footnote = "Fuente: Elaboraci√≥n propia") %>%
     tab_options(heading.title.font.size = 14, 
                 heading.subtitle.font.size = 12,
                 table.font.names = "Century Gothic",
                 table.font.size = 10,
                 data_row.padding = px(1)) %>%
      tab_style(style = list(cell_text(align = "left",
                                       weight = 'bold')),
                locations = list(cells_title(groups = c("title")))) %>%
       tab_style(style = list(cell_text(align = "left")),
                 locations = list(cells_title(groups = c("subtitle")))) %>%
        cols_width(starts_with("Detalles") ~ px(500),
                   everything() ~ px(200)) %>%
         as_raw_html() 
```

## Projection Pursuit (PP)  {-}    

**Projection Pursuit (PP)** es una t√©cnica de **reducci√≥n de dimensionalidad y modelado exploratorio** utilizada para encontrar proyecciones interesantes de datos de alta dimensi√≥n en espacios de baja dimensi√≥n (t√≠picamente 1D o 2D). La idea fundamental de Projection Pursuit es que, en datos de alta dimensi√≥n, las estructuras interesantes (como agrupaciones, frentes, o anomal√≠as) a menudo se ocultan cuando se observan solo las proyecciones marginales de las variables individuales. PP busca **proyecciones "interesantes"** que revelen estas estructuras no gaussianas y no lineales, que podr√≠an pasar desapercibidas con t√©cnicas lineales como PCA.

A diferencia de PCA, que busca las proyecciones que maximizan la varianza (lo cual es √≥ptimo si los datos son elipsoidales o gaussianos), PP busca proyecciones que se desv√≠an de la distribuci√≥n normal. Esto se logra mediante la definici√≥n de una **funci√≥n de "√≠ndice de proyecci√≥n"** que cuantifica la "interesante" o "no-gaussiana" de una proyecci√≥n. El algoritmo entonces busca activamente las direcciones que maximizan este √≠ndice.

El proceso general de Projection Pursuit es iterativo:

1.  **Definici√≥n del √çndice de Proyecci√≥n:** Se elige una funci√≥n de √≠ndice de proyecci√≥n que penalice la normalidad y recompense las desviaciones (ej., asimetr√≠a, curtosis, o medidas basadas en entrop√≠a). Por ejemplo, un √≠ndice de proyecci√≥n podr√≠a buscar distribuciones multimodales o con colas pesadas.
2.  **Optimizaci√≥n:** El algoritmo utiliza t√©cnicas de optimizaci√≥n num√©rica (como descenso de gradiente) para encontrar la direcci√≥n de proyecci√≥n (un vector que define la combinaci√≥n lineal de las caracter√≠sticas originales) que maximiza el √≠ndice de proyecci√≥n.
3.  **Extracci√≥n de Componentes:** Una vez que se encuentra una proyecci√≥n interesante, los datos se proyectan sobre esta direcci√≥n. A menudo, el proceso se repite para encontrar proyecciones ortogonales adicionales, cada una revelando diferentes aspectos de la estructura de los datos.

**Aplicaciones de PP:**

* **Visualizaci√≥n de Datos:** Para encontrar proyecciones 1D o 2D que revelen patrones o agrupaciones.
* **Clasificaci√≥n y Regresi√≥n:** Puede ser una etapa de preprocesamiento para encontrar caracter√≠sticas m√°s informativas, o incluso puede ser la base para construir modelos (como en **Projection Pursuit Regression - PPR**).

En el contexto del **aprendizaje global vs. local**, Projection Pursuit es una t√©cnica que busca descubrir y modelar estructuras **globales** interesantes en los datos a trav√©s de una serie de **proyecciones lineales, pero la combinaci√≥n de estas proyecciones para capturar la no linealidad es la clave**. Aunque las proyecciones individuales son lineales, el proceso de buscar iterativamente las proyecciones "m√°s interesantes" y luego combinarlas permite a PP descubrir y representar relaciones **no lineales** en el conjunto de datos.

Si los datos no se distribuyen linealmente, PP es una herramienta poderosa porque **no asume linealidad** en la estructura subyacente. En lugar de ello, busca activamente las direcciones que revelan la no linealidad y la no-gaussianidad. Esto es precisamente lo que lo diferencia de PCA. La idea de que "si los datos no se distribuyen linealmente, se puede aplicar el concepto de regresi√≥n de manera ponderada localmente" es algo que PPR (una extensi√≥n de PP para regresi√≥n) aborda. PPR construye un modelo como una suma de funciones suaves no lineales de varias proyecciones uni-dimensionales de los predictores, lo que permite capturar relaciones complejas que no pueden ser modeladas por una regresi√≥n lineal simple. Por lo tanto, Projection Pursuit aborda la limitaci√≥n de que "a veces ning√∫n valor de par√°metro puede proporcionar una aproximaci√≥n suficientemente buena" en modelos lineales o simples, al buscar activamente y explotar las caracter√≠sticas no lineales y de "inter√©s" en las proyecciones de los datos.

```{r, echo = FALSE}
criterios <- c(
  "Tipo de modelo",
  "Variable respuesta",
  "Variables predictoras",
  "Relaci√≥n entre variables",
  "Normalidad de residuos",
  "Independencia de errores",
  "Homoscedasticidad",
  "Sensible a outliers",
  "Multicolinealidad entre predictores",
  "Interpretabilidad",
  "Velocidad y eficiencia",
  "Validaci√≥n cruzada",
  "No funciona bien si..."
)

aplica <- c(
  "‚ùå No supervisado (reducci√≥n de dimensionalidad)",
  "‚ùå No aplica (no hay variable respuesta)",
  "‚úÖ Num√©ricas (requiere matriz de datos)",
  "‚úÖ Detecta proyecciones no lineales con estructura interesante",
  "‚ùå No aplica",
  "‚ùå No aplica",
  "‚ùå No aplica",
  "‚ö†Ô∏è Puede ser sensible a valores extremos",
  "‚ö†Ô∏è Puede verse afectado si hay alta redundancia",
  "‚ö†Ô∏è Interpretaci√≥n m√°s dif√≠cil que PCA; proyecciones no son ortogonales",
  "‚ùå Puede ser lento por b√∫squeda iterativa de proyecciones",
  "‚ö†Ô∏è Validaci√≥n subjetiva o basada en heur√≠sticas de inter√©s",
  "‚ùå No √∫til si no hay estructuras no gaussianas en los datos"
)

detalles <- c(
  "M√©todo no supervisado que busca proyecciones de los datos donde se maximice cierta 'interesantitud' (varianza no gaussiana, agrupamientos, etc.).",
  "No est√° dise√±ado para predicci√≥n, sino para exploraci√≥n visual o estructural.",
  "Se aplica a datos num√©ricos, generalmente estandarizados, buscando direcciones relevantes.",
  "A diferencia del PCA (que busca m√°xima varianza), PP busca patrones como colas pesadas, clusters, o distribuciones no normales.",
  "No es un modelo predictivo, por tanto no se calculan residuos.",
  "No se modela el error; se enfoca en la estructura interna de los datos.",
  "No tiene varianzas residuales, por lo que no aplica homoscedasticidad.",
  "Proyecciones pueden verse distorsionadas por valores extremos.",
  "Variables muy correlacionadas pueden dominar las proyecciones si no se controlan.",
  "Proyecciones son dif√≠ciles de interpretar directamente; pueden requerir an√°lisis posterior.",
  "Requiere m√©todos num√©ricos iterativos para encontrar direcciones de inter√©s, lo que lo vuelve computacionalmente intensivo.",
  "Puede usarse validaci√≥n visual (por ejemplo, si se detectan agrupamientos) o criterios como 'kurtosis'.",
  "Si los datos son gaussianos y no contienen patrones relevantes, PP no encuentra proyecciones √∫tiles."
)

tabla_pp <- data.frame(Criterio = criterios, Aplica = aplica, Detalles = detalles)

tabla_pp %>%
 gt() %>%
  tab_header(title = "Gu√≠a r√°pida para elegir PP",
             subtitle = "Projection Pursuit (PP) ")  %>%
   tab_footnote(footnote = "Fuente: Elaboraci√≥n propia") %>%
     tab_options(heading.title.font.size = 14, 
                 heading.subtitle.font.size = 12,
                 table.font.names = "Century Gothic",
                 table.font.size = 10,
                 data_row.padding = px(1)) %>%
      tab_style(style = list(cell_text(align = "left",
                                       weight = 'bold')),
                locations = list(cells_title(groups = c("title")))) %>%
       tab_style(style = list(cell_text(align = "left")),
                 locations = list(cells_title(groups = c("subtitle")))) %>%
        cols_width(starts_with("Detalles") ~ px(500),
                   everything() ~ px(200)) %>%
         as_raw_html() 
```

## Principal Component Regression (PCR)  {-}    

**Principal Component Regression (PCR)** es una t√©cnica de **regresi√≥n** que aborda el problema de la **multicolinealidad** (altas correlaciones entre las variables predictoras) en la regresi√≥n lineal. La idea fundamental de PCR es utilizar el **An√°lisis de Componentes Principales (PCA)** como un paso previo a la regresi√≥n. En lugar de realizar la regresi√≥n directamente sobre las variables predictoras originales, PCR primero transforma las variables predictoras en un conjunto de **componentes principales no correlacionados** y luego realiza la regresi√≥n sobre un subconjunto de estos componentes.

El proceso de Principal Component Regression consta de los siguientes pasos:

1.  **An√°lisis de Componentes Principales (PCA) en las Predictoras:**
    * Primero, se aplica PCA **√∫nicamente a las variables predictoras ($X$)**. Esto genera un nuevo conjunto de variables, los **componentes principales**, que son combinaciones lineales ortogonales de las predictoras originales.
    * Los componentes principales se ordenan por la cantidad de varianza que explican en las variables $X$. El primer componente explica la mayor varianza, el segundo la siguiente mayor varianza, y as√≠ sucesivamente.

2.  **Selecci√≥n de Componentes Principales:**
    * Se selecciona un subconjunto de los componentes principales (normalmente los primeros $k$ componentes que explican una gran proporci√≥n de la varianza total en $X$, o que se consideran m√°s relevantes). La elecci√≥n de $k$ es crucial y a menudo se determina mediante validaci√≥n cruzada.
    * Es importante destacar que, a diferencia de PLSR (Partial Least Squares Regression), PCA en PCR solo considera la varianza de las variables predictoras, no su relaci√≥n con la variable de respuesta.

3.  **Regresi√≥n Lineal M√∫ltiple:**
    * Finalmente, se realiza una **regresi√≥n lineal m√∫ltiple** est√°ndar de la variable de respuesta ($Y$) sobre el subconjunto seleccionado de componentes principales. Dado que los componentes principales son ortogonales (no correlacionados), los problemas de multicolinealidad se eliminan eficazmente.

**Ventajas clave de PCR:**

* **Manejo de Multicolinealidad:** Elimina el problema de la multicolinealidad, lo que lleva a estimaciones de coeficientes m√°s estables y una mejor interpretabilidad en el contexto de los componentes principales.
* **Reducci√≥n de Dimensionalidad:** Puede ser muy √∫til cuando hay un gran n√∫mero de variables predictoras, ya que permite trabajar con un conjunto reducido de componentes que capturan la mayor parte de la informaci√≥n.
* **Reducci√≥n de Ruido:** Al centrarse en los componentes que explican la mayor varianza, puede ayudar a reducir el impacto del ruido en las variables predictoras.

En el contexto del **aprendizaje global vs. local**, Principal Component Regression es un m√©todo de **aprendizaje global**. PCA (la primera etapa de PCR) busca una transformaci√≥n lineal **global** de los datos que capture la m√°xima varianza. La regresi√≥n posterior tambi√©n es un modelo lineal global sobre estos componentes transformados.

Si bien PCR es una mejora sobre la regresi√≥n OLS cuando hay multicolinealidad, sigue siendo fundamentalmente un m√©todo **lineal**. La idea es que, si los datos no se distribuyen linealmente, PCR, en su forma lineal, **no puede capturar relaciones no lineales complejas** entre las variables originales y la variable de respuesta. Su capacidad para manejar la no linealidad es limitada a lo que puede ser capturado por las combinaciones lineales de las caracter√≠sticas originales. Precisamente porque busca una relaci√≥n lineal global en un espacio transformado linealmente, puede enfrentar la situaci√≥n de que "a veces ning√∫n valor de par√°metro puede proporcionar una aproximaci√≥n suficientemente buena" si la relaci√≥n subyacente entre las variables predictoras y la variable de respuesta es intr√≠nsecamente no lineal. Para tales casos, se necesitar√≠an m√©todos de regresi√≥n no lineal o algoritmos de *machine learning* que puedan modelar la no linealidad, como los √°rboles de decisi√≥n, SVM con kernels no lineales, o redes neuronales.


```{r, echo = FALSE}
criterios <- c(
  "Tipo de modelo",
  "Variable respuesta",
  "Variables predictoras",
  "Relaci√≥n entre variables",
  "Normalidad de residuos",
  "Independencia de errores",
  "Homoscedasticidad",
  "Sensible a outliers",
  "Multicolinealidad entre predictores",
  "Interpretabilidad",
  "Velocidad y eficiencia",
  "Validaci√≥n cruzada",
  "No funciona bien si..."
)

aplica <- c(
  "‚úÖ Supervisado (combinaci√≥n de PCA + regresi√≥n)",
  "‚úÖ Variable continua (num√©rica)",
  "‚úÖ Num√©ricas (se aplica PCA primero)",
  "‚úÖ Puede capturar relaciones lineales (con reducci√≥n de dimensionalidad)",
  "‚ö†Ô∏è Requiere verificar residuos del modelo final",
  "‚ö†Ô∏è Se deben revisar los residuos como en regresi√≥n cl√°sica",
  "‚ö†Ô∏è Requiere diagn√≥stico posterior a la regresi√≥n",
  "‚ö†Ô∏è PCA puede estar influenciada por outliers",
  "‚úÖ Reduce multicolinealidad usando componentes ortogonales",
  "‚ö†Ô∏è Menos interpretable (usa componentes, no variables originales)",
  "‚úÖ Eficiente, especialmente con datos de alta dimensi√≥n",
  "‚úÖ Puede usar validaci√≥n cruzada para elegir n√∫mero de componentes",
  "‚ùå Si las primeras componentes no explican bien la variable respuesta"
)

detalles <- c(
  "Modelo supervisado que aplica PCA a los predictores y luego ajusta una regresi√≥n lineal sobre los componentes principales seleccionados.",
  "Se requiere que la variable dependiente sea num√©rica (continua).",
  "Se espera que los predictores sean num√©ricos para aplicar PCA adecuadamente.",
  "PCR puede detectar relaciones lineales al reducir la dimensionalidad primero y luego ajustar la regresi√≥n.",
  "Aunque el PCA es no supervisado, los residuos de la regresi√≥n deben ser normales para cumplir los supuestos de OLS.",
  "Es necesario revisar la independencia de errores como en cualquier regresi√≥n lineal.",
  "Tambi√©n deben analizarse posibles problemas de heterocedasticidad en los residuos.",
  "Outliers pueden influir en los componentes principales y, por lo tanto, en el modelo final.",
  "PCR es muy √∫til cuando los predictores est√°n altamente correlacionados.",
  "Interpretar los resultados puede ser dif√≠cil porque las componentes no corresponden a variables originales.",
  "El proceso es r√°pido incluso con muchos predictores, ya que PCA reduce la dimensi√≥n.",
  "Usualmente se usa validaci√≥n cruzada para determinar cu√°ntas componentes usar.",
  "No es efectivo si los primeros componentes (con mayor varianza) no est√°n relacionados con la variable dependiente."
)

tabla_pcr <- data.frame(Criterio = criterios, Aplica = aplica, Detalles = detalles)

tabla_pcr %>%
 gt() %>%
  tab_header(title = "Gu√≠a r√°pida para elegir PCR",
             subtitle = "Principal Component Regression (PCR)")  %>%
   tab_footnote(footnote = "Fuente: Elaboraci√≥n propia") %>%
     tab_options(heading.title.font.size = 14, 
                 heading.subtitle.font.size = 12,
                 table.font.names = "Century Gothic",
                 table.font.size = 10,
                 data_row.padding = px(1)) %>%
      tab_style(style = list(cell_text(align = "left",
                                       weight = 'bold')),
                locations = list(cells_title(groups = c("title")))) %>%
       tab_style(style = list(cell_text(align = "left")),
                 locations = list(cells_title(groups = c("subtitle")))) %>%
        cols_width(starts_with("Detalles") ~ px(500),
                   everything() ~ px(200)) %>%
         as_raw_html() 
```

## Partial Least Squares Discriminant Analysis (PLSDA)  {-}  

```{r, echo = FALSE}
criterios <- c(
  "Tipo de modelo",
  "Variable respuesta",
  "Variables predictoras",
  "Relaci√≥n entre variables",
  "Normalidad de residuos",
  "Independencia de errores",
  "Homoscedasticidad",
  "Sensible a outliers",
  "Multicolinealidad entre predictores",
  "Interpretabilidad",
  "Velocidad y eficiencia",
  "Validaci√≥n cruzada",
  "No funciona bien si..."
)

aplica <- c(
  "‚úÖ Supervisado (clasificaci√≥n)",
  "‚úÖ Categ√≥rica (binaria o multicategor√≠a)",
  "‚úÖ Num√©ricas (se proyectan a componentes)",
  "‚úÖ Captura relaciones lineales y no lineales a trav√©s de proyecciones",
  "‚ùå No aplica directamente (modelo de clasificaci√≥n)",
  "‚ùå No aplica como en regresi√≥n cl√°sica",
  "‚ùå No se eval√∫a como en modelos de regresi√≥n",
  "‚ö†Ô∏è Algo sensible a outliers (pueden influir en componentes)",
  "‚úÖ Muy √∫til si hay multicolinealidad",
  "‚ö†Ô∏è Menos interpretable que modelos cl√°sicos; depende de componentes",
  "‚úÖ Eficiente, especialmente con datos de alta dimensi√≥n",
  "‚úÖ Se recomienda usar validaci√≥n cruzada para elegir el n√∫mero de componentes",
  "‚ùå Si las proyecciones no separan bien las clases o hay mucho ruido"
)

detalles <- c(
  "Modelo supervisado de clasificaci√≥n basado en PLS (Partial Least Squares) que proyecta los datos para maximizar la separaci√≥n entre clases.",
  "Se requiere que la variable dependiente sea categ√≥rica. PLS-DA funciona bien con 2 o m√°s clases.",
  "Las variables predictoras deben ser num√©ricas para que el modelo pueda proyectarlas en componentes latentes.",
  "El modelo encuentra combinaciones de predictores que mejor separan las clases en el espacio proyectado.",
  "No se eval√∫a normalidad de residuos como en modelos de regresi√≥n; la salida es de clasificaci√≥n.",
  "Tampoco aplica la independencia cl√°sica de errores ya que se clasifican observaciones.",
  "El supuesto de homoscedasticidad no es relevante aqu√≠.",
  "Outliers pueden afectar la construcci√≥n de componentes, distorsionando la separaci√≥n de clases.",
  "PLS-DA es √∫til cuando los predictores est√°n altamente correlacionados, ya que crea componentes ortogonales.",
  "Los componentes no son directamente interpretables como las variables originales, aunque se pueden analizar los pesos de carga.",
  "Es un algoritmo relativamente eficiente, especialmente para conjuntos con muchas variables.",
  "La validaci√≥n cruzada es cr√≠tica para seleccionar el n√∫mero √≥ptimo de componentes y evitar overfitting.",
  "No funciona bien si las clases no est√°n bien separadas en el espacio proyectado o si hay demasiado ruido en los datos."
)

tabla_plsda <- data.frame(Criterio = criterios, Aplica = aplica, Detalles = detalles)

tabla_plsda %>%
 gt() %>%
  tab_header(title = "Gu√≠a r√°pida para elegir PLSDA",
             subtitle = "Partial Least Squares Discriminant Analysis (PLSDA)")  %>%
   tab_footnote(footnote = "Fuente: Elaboraci√≥n propia") %>%
     tab_options(heading.title.font.size = 14, 
                 heading.subtitle.font.size = 12,
                 table.font.names = "Century Gothic",
                 table.font.size = 10,
                 data_row.padding = px(1)) %>%
      tab_style(style = list(cell_text(align = "left",
                                       weight = 'bold')),
                locations = list(cells_title(groups = c("title")))) %>%
       tab_style(style = list(cell_text(align = "left")),
                 locations = list(cells_title(groups = c("subtitle")))) %>%
        cols_width(starts_with("Detalles") ~ px(500),
                   everything() ~ px(200)) %>%
         as_raw_html() 
```

## Mixture Discriminant Analysis (MDA)  {-}  

```{r, echo = FALSE}
criterios <- c(
  "Tipo de modelo",
  "Variable respuesta",
  "Variables predictoras",
  "Relaci√≥n entre variables",
  "Normalidad de residuos",
  "Independencia de errores",
  "Homoscedasticidad",
  "Sensible a outliers",
  "Multicolinealidad entre predictores",
  "Interpretabilidad",
  "Velocidad y eficiencia",
  "Validaci√≥n cruzada",
  "No funciona bien si..."
)

aplica <- c(
  "‚úÖ Supervisado (clasificaci√≥n)",
  "‚úÖ Categ√≥rica (clases)",
  "‚úÖ Num√©ricas",
  "‚úÖ No lineal (usa mezclas de gaussianas para modelar clases)",
  "‚ùå No aplica como en regresi√≥n",
  "‚ùå No se eval√∫a como en regresi√≥n",
  "‚ö†Ô∏è Supone varianza homog√©nea dentro de componentes, pero puede variar entre clases",
  "‚ö†Ô∏è Puede ser sensible a outliers (afectan las medias y covarianzas)",
  "‚ö†Ô∏è Puede verse afectado, aunque usa reducci√≥n dimensional",
  "‚ö†Ô∏è Moderadamente interpretable (depende de componentes gaussianos)",
  "‚ö†Ô∏è M√°s lento que LDA/QDA, pero m√°s flexible",
  "‚úÖ Recomendable para elegir n√∫mero de componentes y evitar sobreajuste",
  "‚ùå Mal desempe√±o si la distribuci√≥n dentro de clases no es bien modelada por gaussianas"
)

detalles <- c(
  "Modelo supervisado de clasificaci√≥n que combina regresi√≥n discriminante con mezclas gaussianas dentro de cada clase.",
  "Se usa para clasificar observaciones en grupos definidos por una variable categ√≥rica.",
  "Requiere predictores num√©ricos para ajustar distribuciones normales multivariadas.",
  "Modela cada clase como una combinaci√≥n de distribuciones gaussianas, permitiendo formas no lineales.",
  "No hay residuos como en regresi√≥n, ya que se trata de una tarea de clasificaci√≥n.",
  "No eval√∫a independencia cl√°sica de errores; se enfoca en estimar la densidad condicional.",
  "Permite varianza distinta entre componentes, pero se puede ajustar homogeneidad seg√∫n implementaci√≥n.",
  "Outliers pueden afectar las medias y varianzas estimadas de las mezclas gaussianas.",
  "La multicolinealidad puede dificultar la estimaci√≥n de matrices de covarianza.",
  "Interpretar los componentes internos (medias y pesos) puede ser complejo, pero ofrece buena visualizaci√≥n.",
  "Es m√°s lento que LDA o QDA por su naturaleza iterativa y uso de EM (Expectation-Maximization).",
  "Se puede usar validaci√≥n cruzada para seleccionar el n√∫mero √≥ptimo de mezclas por clase.",
  "Si las clases no se ajustan bien a combinaciones de gaussianas, el modelo pierde precisi√≥n."
)

tabla_mda <- data.frame(Criterio = criterios, Aplica = aplica, Detalles = detalles)

tabla_mda %>%
 gt() %>%
  tab_header(title = "Gu√≠a r√°pida para elegir MDA",
             subtitle = "Mixture Discriminant Analysis (MDA)")  %>%
   tab_footnote(footnote = "Fuente: Elaboraci√≥n propia") %>%
     tab_options(heading.title.font.size = 14, 
                 heading.subtitle.font.size = 12,
                 table.font.names = "Century Gothic",
                 table.font.size = 10,
                 data_row.padding = px(1)) %>%
      tab_style(style = list(cell_text(align = "left",
                                       weight = 'bold')),
                locations = list(cells_title(groups = c("title")))) %>%
       tab_style(style = list(cell_text(align = "left")),
                 locations = list(cells_title(groups = c("subtitle")))) %>%
        cols_width(starts_with("Detalles") ~ px(500),
                   everything() ~ px(200)) %>%
         as_raw_html() 
```


## Quadratic Discriminant Analysis (QDA) {-}  

```{r, echo = FALSE}
criterios <- c(
  "Tipo de modelo",
  "Variable respuesta",
  "Variables predictoras",
  "Relaci√≥n entre variables",
  "Normalidad de residuos",
  "Independencia de errores",
  "Homoscedasticidad",
  "Sensible a outliers",
  "Multicolinealidad entre predictores",
  "Interpretabilidad",
  "Velocidad y eficiencia",
  "Validaci√≥n cruzada",
  "No funciona bien si..."
)

aplica <- c(
  "‚úÖ Supervisado (clasificaci√≥n)",
  "‚úÖ Categ√≥rica (clases)",
  "‚úÖ Num√©ricas",
  "‚úÖ Modela separaci√≥n cuadr√°tica entre clases",
  "‚ùå No aplica (clasificaci√≥n, no regresi√≥n)",
  "‚ùå No aplica (se asume independencia dentro de clases)",
  "‚ùå No se asume homoscedasticidad (cada clase tiene su propia matriz de covarianza)",
  "‚ö†Ô∏è Puede ser muy sensible a outliers (afectan las matrices de covarianza)",
  "‚ö†Ô∏è Puede verse afectado, especialmente si hay pocos datos",
  "‚úÖ Relativamente interpretable (fronteras no lineales entre clases)",
  "‚ö†Ô∏è M√°s costoso que LDA; ineficiente con pocos datos o muchas variables",
  "‚úÖ Recomendado para evitar overfitting, especialmente con pocos datos",
  "‚ùå Si hay pocos datos por clase, estimar matrices de covarianza es inestable"
)

detalles <- c(
  "Modelo supervisado de clasificaci√≥n que permite que cada clase tenga su propia matriz de covarianza.",
  "Se utiliza para predecir a qu√© clase pertenece una observaci√≥n con base en sus caracter√≠sticas.",
  "Requiere predictores num√©ricos continuos, ya que calcula medias y covarianzas.",
  "A diferencia de LDA, permite fronteras no lineales al no asumir varianzas iguales entre clases.",
  "No tiene residuos como en regresi√≥n, por lo que el supuesto de normalidad de errores no aplica.",
  "No aplica el supuesto de independencia de errores; se enfoca en la distribuci√≥n conjunta por clase.",
  "Cada clase tiene su propia varianza y covarianza, lo que lo hace m√°s flexible que LDA.",
  "Valores extremos pueden distorsionar la estimaci√≥n de medias y covarianzas de cada clase.",
  "Multicolinealidad puede dificultar la inversi√≥n de la matriz de covarianza en clases peque√±as.",
  "Los coeficientes y decisiones son interpretables en t√©rminos de separaciones estad√≠sticas entre clases.",
  "M√°s lento y costoso computacionalmente que LDA, especialmente con muchas variables.",
  "La validaci√≥n cruzada ayuda a prevenir sobreajuste y a seleccionar caracter√≠sticas relevantes.",
  "Con clases poco representadas o muchas variables, las matrices de covarianza pueden volverse inestables."
)

tabla_qda <- data.frame(Criterio = criterios, Aplica = aplica, Detalles = detalles) 

tabla_qda %>%
 gt() %>%
  tab_header(title = "Gu√≠a r√°pida para elegir QDA",
             subtitle = "Quadratic Discriminant Analysis (QDA)")  %>%
   tab_footnote(footnote = "Fuente: Elaboraci√≥n propia") %>%
     tab_options(heading.title.font.size = 14, 
                 heading.subtitle.font.size = 12,
                 table.font.names = "Century Gothic",
                 table.font.size = 10,
                 data_row.padding = px(1)) %>%
      tab_style(style = list(cell_text(align = "left",
                                       weight = 'bold')),
                locations = list(cells_title(groups = c("title")))) %>%
       tab_style(style = list(cell_text(align = "left")),
                 locations = list(cells_title(groups = c("subtitle")))) %>%
        cols_width(starts_with("Detalles") ~ px(500),
                   everything() ~ px(200)) %>%
         as_raw_html() 
```

## Regularized Discriminant Analysis (RDA)  {-}   

```{r, echo = FALSE}
criterios <- c(
  "Tipo de modelo",
  "Variable respuesta",
  "Variables predictoras",
  "Relaci√≥n entre variables",
  "Normalidad de residuos",
  "Independencia de errores",
  "Homoscedasticidad",
  "Sensible a outliers",
  "Multicolinealidad entre predictores",
  "Interpretabilidad",
  "Velocidad y eficiencia",
  "Validaci√≥n cruzada",
  "No funciona bien si..."
)

aplica <- c(
  "‚úÖ Supervisado (clasificaci√≥n)",
  "‚úÖ Categ√≥rica (clases)",
  "‚úÖ Num√©ricas",
  "‚úÖ No lineal (transici√≥n entre LDA y QDA)",
  "‚ùå No aplica (no es un modelo de regresi√≥n)",
  "‚ùå No aplica directamente",
  "‚ö†Ô∏è Controla la homoscedasticidad mediante regularizaci√≥n",
  "‚ö†Ô∏è Puede ser sensible, aunque la regularizaci√≥n reduce impacto",
  "‚úÖ Reduce impacto mediante regularizaci√≥n de covarianzas",
  "‚ö†Ô∏è Menos interpretable que LDA/QDA puro, pero con mayor flexibilidad",
  "‚úÖ M√°s eficiente que QDA en conjuntos peque√±os o ruidosos",
  "‚úÖ Muy √∫til para evitar overfitting, sobre todo con validaci√≥n cruzada",
  "‚ùå Puede no mejorar sobre LDA/QDA si no hay problemas de varianza o sobreajuste"
)

detalles <- c(
  "Modelo supervisado de clasificaci√≥n que combina LDA y QDA usando par√°metros de regularizaci√≥n.",
  "Clasifica observaciones en clases discretas bas√°ndose en variables num√©ricas predictoras.",
  "Requiere variables num√©ricas para calcular medias y covarianzas por clase.",
  "Introduce par√°metros de mezcla que ajustan la matriz de covarianza hacia la identidad (como ridge) y hacia la covarianza com√∫n.",
  "No genera residuos como un modelo de regresi√≥n, por lo tanto el supuesto no aplica.",
  "No se enfoca en errores independientes, sino en distribuciones de clase.",
  "La regularizaci√≥n suaviza las diferencias entre covarianzas, mitigando problemas de homoscedasticidad.",
  "Los valores at√≠picos pueden influir en la estimaci√≥n, pero se reduce con regularizaci√≥n.",
  "Mejor manejo de multicolinealidad que QDA gracias a la matriz regularizada.",
  "La interpretaci√≥n depende de los valores de regularizaci√≥n elegidos; m√°s flexible pero menos directa.",
  "Reduce complejidad computacional respecto a QDA; √∫til con pocas observaciones por clase.",
  "Es com√∫n usar validaci√≥n cruzada para seleccionar los par√°metros de regularizaci√≥n √≥ptimos.",
  "No aporta mejoras significativas si los supuestos de LDA o QDA se cumplen perfectamente sin sobreajuste."
)

tabla_rda <- data.frame(Criterio = criterios, Aplica = aplica, Detalles = detalles)


tabla_rda %>%
 gt() %>%
  tab_header(title = "Gu√≠a r√°pida para elegir RDA",
             subtitle = "Regularized Discriminant Analysis (RDA)")  %>%
   tab_footnote(footnote = "Fuente: Elaboraci√≥n propia") %>%
     tab_options(heading.title.font.size = 14, 
                 heading.subtitle.font.size = 12,
                 table.font.names = "Century Gothic",
                 table.font.size = 10,
                 data_row.padding = px(1)) %>%
      tab_style(style = list(cell_text(align = "left",
                                       weight = 'bold')),
                locations = list(cells_title(groups = c("title")))) %>%
       tab_style(style = list(cell_text(align = "left")),
                 locations = list(cells_title(groups = c("subtitle")))) %>%
        cols_width(starts_with("Detalles") ~ px(500),
                   everything() ~ px(200)) %>%
         as_raw_html() 
```



## Flexible Discriminant Analysis (FDA)  {-}  

```{r, echo = FALSE}
criterios <- c(
  "Tipo de modelo",
  "Variable respuesta",
  "Variables predictoras",
  "Relaci√≥n entre variables",
  "Normalidad de residuos",
  "Independencia de errores",
  "Homoscedasticidad",
  "Sensible a outliers",
  "Multicolinealidad entre predictores",
  "Interpretabilidad",
  "Velocidad y eficiencia",
  "Validaci√≥n cruzada",
  "No funciona bien si..."
)

aplica <- c(
  "‚úÖ Supervisado (clasificaci√≥n)",
  "‚úÖ Categ√≥rica (clases)",
  "‚úÖ Num√©ricas (puede usar transformaciones)",
  "‚úÖ No lineal (usa regresi√≥n flexible en el espacio transformado)",
  "‚ùå No aplica (no es regresi√≥n de residuos)",
  "‚ùå No aplica directamente",
  "‚ö†Ô∏è FDA suaviza este supuesto al modelar relaciones no lineales",
  "‚ö†Ô∏è Puede ser sensible a outliers, dependiendo del m√©todo de ajuste",
  "‚ö†Ô∏è Puede mitigar multicolinealidad si se usa penalizaci√≥n",
  "‚ö†Ô∏è Menos interpretable que LDA, pero permite mayor flexibilidad",
  "‚ö†Ô∏è Menor eficiencia que LDA por mayor complejidad computacional",
  "‚úÖ Validaci√≥n cruzada √∫til para seleccionar transformaciones o suavizados",
  "‚ùå En datos con pocos casos o ruido excesivo puede sobreajustarse"
)

detalles <- c(
  "Extensi√≥n de LDA que permite relaciones no lineales entre predictores y clases mediante t√©cnicas como splines o regresi√≥n flexible.",
  "Clasifica observaciones en clases categ√≥ricas bas√°ndose en predictores transformados.",
  "Admite variables num√©ricas, las cuales pueden ser transformadas de forma no lineal.",
  "Usa regresi√≥n no lineal flexible (como splines) para modelar relaciones complejas en el espacio de discriminaci√≥n.",
  "No genera residuos como regresi√≥n tradicional; es un modelo de clasificaci√≥n.",
  "No se enfoca en errores secuenciales o dependientes.",
  "Relaja la homocedasticidad al no asumir distribuci√≥n gaussiana estricta.",
  "Puede verse afectado por valores extremos, seg√∫n el m√©todo de suavizado.",
  "La transformaci√≥n flexible puede reducir colinealidad, pero no siempre la elimina.",
  "Los coeficientes y funciones discriminantes pueden ser dif√≠ciles de interpretar si se usan transformaciones complejas.",
  "Mayor costo computacional que LDA, pero m√°s potente en patrones no lineales.",
  "Se recomienda CV para evaluar desempe√±o y evitar overfitting en el proceso de ajuste flexible.",
  "Si los datos no requieren flexibilidad o el tama√±o muestral es bajo, FDA puede ser innecesariamente complejo."
)

tabla_fda <- data.frame(Criterio = criterios, Aplica = aplica, Detalles = detalles)

tabla_fda %>%
 gt() %>%
  tab_header(title = "Gu√≠a r√°pida para elegir FDA",
             subtitle = "Flexible Discriminant Analysis (FDA)")  %>%
   tab_footnote(footnote = "Fuente: Elaboraci√≥n propia") %>%
     tab_options(heading.title.font.size = 14, 
                 heading.subtitle.font.size = 12,
                 table.font.names = "Century Gothic",
                 table.font.size = 10,
                 data_row.padding = px(1)) %>%
      tab_style(style = list(cell_text(align = "left",
                                       weight = 'bold')),
                locations = list(cells_title(groups = c("title")))) %>%
       tab_style(style = list(cell_text(align = "left")),
                 locations = list(cells_title(groups = c("subtitle")))) %>%
        cols_width(starts_with("Detalles") ~ px(500),
                   everything() ~ px(200)) %>%
         as_raw_html() 
```



## Linear Discriminant Analysis (LDA)  {-}   

```{r, echo = FALSE}
criterios <- c(
  "Tipo de modelo",
  "Variable respuesta",
  "Variables predictoras",
  "Relaci√≥n entre variables",
  "Normalidad de residuos",
  "Independencia de errores",
  "Homoscedasticidad",
  "Sensible a outliers",
  "Multicolinealidad entre predictores",
  "Interpretabilidad",
  "Velocidad y eficiencia",
  "Validaci√≥n cruzada",
  "No funciona bien si..."
)

aplica <- c(
  "‚úÖ Supervisado (clasificaci√≥n)",
  "‚úÖ Categ√≥rica (clases)",
  "‚úÖ Num√©ricas (preferentemente)",
  "‚úÖ Asume relaciones lineales entre variables y clases",
  "‚úÖ Supone normalidad multivariante de los predictores dentro de cada clase",
  "‚úÖ Supone independencia entre observaciones",
  "‚úÖ Asume varianza-covarianza igual entre clases (homocedasticidad)",
  "‚ö†Ô∏è Sensible a valores at√≠picos",
  "‚ö†Ô∏è Puede verse afectado negativamente por alta colinealidad",
  "‚úÖ Alta, coeficientes discriminantes son interpretables",
  "‚úÖ Muy eficiente computacionalmente",
  "‚úÖ Se recomienda para evaluar estabilidad y evitar sobreajuste",
  "‚ùå Mal desempe√±o si no se cumplen supuestos de normalidad y homocedasticidad"
)

detalles <- c(
  "Modelo supervisado cl√°sico para clasificaci√≥n que encuentra combinaciones lineales de predictores que separan clases.",
  "Requiere una variable categ√≥rica como objetivo, con dos o m√°s clases.",
  "Mejor con predictores num√©ricos continuos; categ√≥ricos requieren codificaci√≥n previa.",
  "Calcula funciones discriminantes lineales que maximizan la separaci√≥n entre clases.",
  "Cada grupo debe seguir una distribuci√≥n normal multivariante para resultados √≥ptimos.",
  "Las observaciones deben ser independientes para validez de inferencia.",
  "Supone igual matriz de covarianzas entre grupos; si no se cumple, usar QDA.",
  "Outliers influyen en la media y la varianza estimada, distorsionando fronteras.",
  "Multicolinealidad puede hacer que los coeficientes discriminantes sean inestables.",
  "Las funciones discriminantes se interpretan como direcciones de m√°xima separaci√≥n.",
  "Requiere bajo costo computacional y se entrena r√°pidamente.",
  "Se puede usar validaci√≥n cruzada para elegir el n√∫mero de componentes o verificar precisi√≥n.",
  "Cuando los datos no cumplen normalidad ni homocedasticidad, el modelo pierde precisi√≥n."
)

tabla_lda <- data.frame(Criterio = criterios, Aplica = aplica, Detalles = detalles)

tabla_lda %>%
 gt() %>%
  tab_header(title = "Gu√≠a r√°pida para elegir LDA",
             subtitle = "Linear Discriminant Analysis (LDA)")  %>%
   tab_footnote(footnote = "Fuente: Elaboraci√≥n propia") %>%
     tab_options(heading.title.font.size = 14, 
                 heading.subtitle.font.size = 12,
                 table.font.names = "Century Gothic",
                 table.font.size = 10,
                 data_row.padding = px(1)) %>%
      tab_style(style = list(cell_text(align = "left",
                                       weight = 'bold')),
                locations = list(cells_title(groups = c("title")))) %>%
       tab_style(style = list(cell_text(align = "left")),
                 locations = list(cells_title(groups = c("subtitle")))) %>%
        cols_width(starts_with("Detalles") ~ px(500),
                   everything() ~ px(200)) %>%
         as_raw_html() 
```

## Uniform Manifold Approximation and Projection (UMAP) {-}  

```{r}
criterios <- c(
  "Tipo de modelo",
  "Variable respuesta",
  "Variables predictoras",
  "Relaci√≥n entre variables",
  "Normalidad de residuos",
  "Independencia de errores",
  "Homoscedasticidad",
  "Sensible a outliers",
  "Multicolinealidad entre predictores",
  "Interpretabilidad",
  "Velocidad y eficiencia",
  "Validaci√≥n cruzada",
  "No funciona bien si..."
)

aplica <- c(
  "‚ùå No supervisado (reducci√≥n de dimensionalidad)",
  "‚ùå No aplica (no hay variable respuesta)",
  "‚úÖ Num√©ricas (o categ√≥ricas codificadas)",
  "‚úÖ Captura relaciones no lineales y estructura local/global",
  "‚ùå No aplica",
  "‚ùå No aplica",
  "‚ùå No aplica",
  "‚ö†Ô∏è Algo sensible a outliers (puede distorsionar estructuras)",
  "‚ö†Ô∏è No afecta directamente (no hay predictores)",
  "‚ö†Ô∏è Visual en 2D o 3D; dif√≠cil interpretaci√≥n formal",
  "‚úÖ Muy r√°pido incluso en grandes conjuntos de datos",
  "‚ö†Ô∏è No usa validaci√≥n cruzada cl√°sica, pero puede evaluarse la estabilidad",
  "‚ùå Datos con mucho ruido, escalas mal ajustadas o sin estructura latente clara"
)

detalles <- c(
  "T√©cnica no supervisada de reducci√≥n de dimensionalidad que preserva tanto estructura local como global de los datos.",
  "No busca predecir, sino proyectar observaciones a un espacio de menor dimensi√≥n.",
  "Funciona con datos num√©ricos; variables categ√≥ricas deben ser codificadas antes.",
  "A diferencia de PCA, puede descubrir relaciones no lineales m√°s complejas.",
  "No genera residuos; no aplica el supuesto de normalidad.",
  "No hay modelo de error residual, por lo que no aplica la independencia.",
  "No es un modelo predictivo, as√≠ que no se eval√∫a homoscedasticidad.",
  "Outliers pueden influir en el mapa de manera desproporcionada.",
  "Como es una t√©cnica de reducci√≥n, la multicolinealidad no le afecta directamente.",
  "La interpretaci√≥n se limita a la distribuci√≥n visual de puntos.",
  "UMAP es computacionalmente eficiente y escalable a grandes vol√∫menes de datos.",
  "No utiliza validaci√≥n cruzada directa, pero puede evaluarse la estabilidad de la proyecci√≥n.",
  "Cuando no existe una estructura clara en los datos, la proyecci√≥n puede ser confusa o poco √∫til."
)

tabla_umap <- data.frame(Criterio = criterios, Aplica = aplica, Detalles = detalles)

tabla_umap %>%
 gt() %>%
  tab_header(title = "Gu√≠a r√°pida para elegir UMAP",
             subtitle = "Uniform Manifold Approximation and Projection (UMAP)")  %>%
   tab_footnote(footnote = "Fuente: Elaboraci√≥n propia") %>%
     tab_options(heading.title.font.size = 14, 
                 heading.subtitle.font.size = 12,
                 table.font.names = "Century Gothic",
                 table.font.size = 10,
                 data_row.padding = px(1)) %>%
      tab_style(style = list(cell_text(align = "left",
                                       weight = 'bold')),
                locations = list(cells_title(groups = c("title")))) %>%
       tab_style(style = list(cell_text(align = "left")),
                 locations = list(cells_title(groups = c("subtitle")))) %>%
        cols_width(starts_with("Detalles") ~ px(500),
                   everything() ~ px(200)) %>%
         as_raw_html() 
```

